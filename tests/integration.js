const test = require('ava');

const request = require('request-promise-native');
const MUUID = require('uuid-mongodb');

test.beforeEach(t => {
  t.context.rawPayment = { 
    "type":"Payment",
    "version":0,
    "organisation_id":"743d5b63-8e6f-432e-a8fa-c5d8d2ee5fcb",
    "attributes":{ 
       "amount":100.21,
       "beneficiary_party":{ 
          "account_name":"W Owens",
          "account_number":"31926819",
          "account_number_code":"BBAN",
          "account_type":0,
          "address":"1 The Beneficiary Localtown SE2",
          "bank_id":"403000",
          "bank_id_code":"GBDSC",
          "name":"Wilfred Jeremiah Owens"
       },
       "charges_information":{ 
          "bearer_code":"SHAR",
          "sender_charges":[ 
             { 
                "amount":5.00,
                "currency":"GBP"
             },
             { 
                "amount":10.00,
                "currency":"USD"
             }
          ],
          "receiver_charges_amount":1.00,
          "receiver_charges_currency":"USD"
       },
       "currency":"GBP",
       "debtor_party":{ 
          "account_name":"EJ Brown Black",
          "account_number":"GB29XABC10161234567801",
          "account_number_code":"IBAN",
          "address":"10 Debtor Crescent Sourcetown NE1",
          "bank_id":"203301",
          "bank_id_code":"GBDSC",
          "name":"Emelia Jane Brown"
       },
       "end_to_end_reference":"Wil piano Jan",
       "fx":{ 
          "contract_reference":"FX123",
          "exchange_rate":2.00000,
          "original_amount":200.42,
          "original_currency":"USD"
       },
       "numeric_reference":1002001,
       "payment_id":"123456789012345678",
       "payment_purpose":"Paying for goods/services",
       "payment_scheme":"FPS",
       "payment_type":"Credit",
       "processing_date":"2017-01-18",
       "reference":"Payment for Ems piano lessons",
       "scheme_payment_sub_type":"InternetBanking",
       "scheme_payment_type":"ImmediatePayment",
       "sponsor_party":{ 
          "account_number":"56781234",
          "bank_id":"123123",
          "bank_id_code":"GBDSC"
       }
    }
  };
})

let TEST_PAYMENT_URL;
test.serial('assert POST', async t => {
  await request
    .post({
      url: `${process.env.DEV_SERVER}/payments`,
      body: t.context.rawPayment,
      json: true,
      resolveWithFullResponse: true
    })
    .then(response => {
      t.truthy(response.headers.location);
      TEST_PAYMENT_URL = `${process.env.DEV_SERVER}${response.headers.location}`;
    })
    .catch(err => {
      console.error(err);
      t.fail();
    });
});

test.serial('assert GET', t => request
  .get(TEST_PAYMENT_URL)
  .then(payment => {
    const paymentObj = JSON.parse(payment);
    t.truthy(paymentObj._id);
    // __v and _id are generated by mongo
    const expected = { _id: paymentObj._id, __v: paymentObj.__v, ...t.context.rawPayment };
    // processing_date is sent as date string but it is stored as datetime
    expected.attributes.processing_date = new Date(expected.attributes.processing_date).toISOString();
    t.deepEqual(paymentObj, expected);
  })
  .catch(err => {
    console.error(err);
    t.fail();
  })
);

test.serial('assert PATCH', async t => {
  const attributes = {
    amount: parseInt(Math.random() * 1e5)/100,
    beneficiary_party: {
      account_number: `${parseInt(Math.random() * 1e8)}`,
      bank_id: `BKID-${Math.random()}`,
      bank_id_code: new Array(5).fill().map(() => String.fromCharCode( 65 + parseInt(Math.random() * 1e3) % 27 )).join('')
    }
  };
  await request
    .patch({
      url: TEST_PAYMENT_URL,
      body: attributes,
      json: true,
    })
    .then(updatedPayment => {
      t.is(updatedPayment.attributes.amount, attributes.amount);
      t.is(updatedPayment.attributes.beneficiary_party.account_number, attributes.beneficiary_party.account_number);
      t.is(updatedPayment.attributes.beneficiary_party.bank_id, attributes.beneficiary_party.bank_id);
      t.is(updatedPayment.attributes.beneficiary_party.bank_id_code, attributes.beneficiary_party.bank_id_code);
      // make sure only presented props are updated and old ones are kept the same
      t.notDeepEqual(updatedPayment.attributes.beneficiary_party, attributes.beneficiary_party);

      // make sure those changes are really stored
      request
        .get(TEST_PAYMENT_URL)
        .then(payment => JSON.parse(payment))
        .then(payment => t.deepEqual(payment, updatedPayment));
    })
    .catch(err => {
      console.error(err);
      t.fail();
    })
});

test.serial('assert DELETE', t => request
  .delete({ url: TEST_PAYMENT_URL, resolveWithFullResponse: true })
  .then(response => {
    t.is(response.statusCode, 204);
    return request.get({ url: TEST_PAYMENT_URL, simple: false, resolveWithFullResponse: true })
  })
  .then(response => t.is(response.statusCode, 404))
  .catch(err => {
    console.error(err);
    t.fail();
  })
);

test.serial('assert empty list', t => request
  .get(`${process.env.DEV_SERVER}/payments`)
  .then(payments => JSON.parse(payments))
  .then(payments => t.deepEqual(payments, []))
);

test.serial('assert existing list', async t => {
  // 4 payments from same org
  await Promise.all(
    new Array(4).fill().map(() => request.post({
      url: `${process.env.DEV_SERVER}/payments`,
      body: t.context.rawPayment,
      json: true
    }))
  )

  // add a different org
  await request.post({
    url: `${process.env.DEV_SERVER}/payments`,
    body: { ...t.context.rawPayment, organisation_id: MUUID.v1() },
    json: true
  });

  await request.get(`${process.env.DEV_SERVER}/payments`)
    .then(payments => JSON.parse(payments))
    .then(payments => t.is(payments.length, 5, 'listing without filter should return all payments'));

  const paymentsIds = await request.get(`${process.env.DEV_SERVER}/payments?organisation_id=${t.context.rawPayment.organisation_id}`)
    .then(payments => JSON.parse(payments))
    .then(payments => {
      t.is(payments.length, 4, 'listing filtered by organisation should return only this org payments');
      return payments.map(p => p._id);
    });

  await request.get(`${process.env.DEV_SERVER}/payments?organisation_id=${t.context.rawPayment.organisation_id}&skip=1&limit=2`)
    .then(payments => JSON.parse(payments))
    .then(payments => {
      t.is(payments.length, 2, 'listing filtered by organisation with maximun of 2 results');
      t.is(payments[0]._id, paymentsIds[1]);
      t.is(payments[1]._id, paymentsIds[2]);
    });
});
